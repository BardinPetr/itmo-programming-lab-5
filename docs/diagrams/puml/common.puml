
@startuml

!theme plain
top to bottom direction
skinparam linetype ortho
skinparam classAttributeIconSize 0
hide circle

<style>
classDiagram {
    class {
        header {
            FontStyle bold
        }
    }
}
</style>
!theme plain
top to bottom direction
skinparam linetype ortho

class Executor {
  + Executor(): 
  - operationMap: Map<Class<APICommand>, Operation<APICommand, ICommandResponse>>
  - childExecutors: List<Executor>
  + MAX_RECURSION_DEPTH: int
  + registerExecutor(Executor): void
  + registerVoidOperation(Class<T>, NoReturnOperation<T>): void
  + execute(APICommand): Response<ICommandResponse>
  + executeBatch(List<APICommand>): List<Response<ICommandResponse>>
  + registerOperation(Class<T>, Operation<T, ICommandResponse>): void
  # execute(APICommand, int): Response<ICommandResponse>
}
class FileAccessException {
  + FileAccessException(String, OperationType): 
  + FileAccessException(Exception, String, OperationType): 
  + FileAccessException(Exception, File, OperationType): 
  + FileAccessException(File, OperationType): 
  - path: String
  - type: OperationType
  + getPath(): String
  + getType(): OperationType
}
class FileController {
  + FileController(String, boolean): 
  + FileController(String): 
  # file: File
  # checkReadAccess(): void
  - loadPath(String): File
  + getPath(): String
  + creationDate(): ZonedDateTime
  # ensureExistence(boolean): boolean
  # checkWriteAccess(): void
  + check(): boolean
  - checkAccess(): void
  - checkExistence(): boolean
}
class FileIOController {
  + FileIOController(String, boolean): 
  + FileIOController(String): 
  + write(byte[]): void
  + openWriteStream(): FileOutputStream
  + clear(): void
  + openReadStream(): FileInputStream
  + read(): byte[]
}
class InvalidDataFileException {
  + InvalidDataFileException(String, byte[], SerDesException): 
  - path: String
  - contents: byte[]
  + getPath(): String
  + getMessage(): String
  + getContents(): byte[]
}
interface NoReturnOperation<T> << interface >> {
  + apply(T): void
}
class ObjectMapperFactory {
  + ObjectMapperFactory(): 
  {static} + createMapper(): ObjectMapper
}
interface Operation<T, V> << interface >> {
  + apply(T): V
}
enum OperationType << enumeration >> {
  - OperationType(String): 
  - OperationType(): 
  + PERM_READ: 
  + OPEN: 
  + PERM_WRITE: 
  + WRITE: 
  + CREATE: 
  + SET_PERMISSION: 
  + READ: 
  - description: String
  + getDescription(): String
  + valueOf(String): OperationType
  + values(): OperationType[]
}
class SerDesException {
  + SerDesException(Type, Exception): 
  - internalException: Exception
  - direction: Type
  + getDirection(): Type
  + getInternalException(): Exception
  + toString(): String
}
abstract class SerDesService<T> <<abstract>> {
  + SerDesService(Class<T>): 
  - mapper: ObjectMapper
  - baseClass: Class<T>
  {abstract} # getObjectMapper(): ObjectMapper
  + serialize(T): byte[]
  + deserialize(byte[]): T
}
enum Type << enumeration >> {
  + Type(): 
  + SERIALIZE: 
  + DESERIALIZE: 
  + valueOf(String): Type
  + values(): Type[]
}
class ValueDeserializer {
  + ValueDeserializer(): 
  - mapper: ObjectMapper
  + deserialize(Class<K>, String): K
}
class XMLSerDesService<T> {
  + XMLSerDesService(Class<T>): 
  # getObjectMapper(): ObjectMapper
}

Executor                  ..>  Operation                
FileAccessException       ..>  OperationType            
FileIOController          --^  FileController           
OperationType             +--  FileAccessException      
SerDesException           ..>  Type                     
Type                      +--  SerDesException          
XMLSerDesService          --^  SerDesService            
@enduml
